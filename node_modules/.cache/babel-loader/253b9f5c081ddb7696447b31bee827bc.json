{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\n\nconst report = require('../../utils/report');\n\nconst ruleMessages = require('../../utils/ruleMessages');\n\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'color-hex-case';\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`\n});\nconst HEX = /^#[0-9A-Za-z]+/;\nconst IGNORED_FUNCTIONS = new Set(['url']);\n\nfunction rule(expectation, options, context) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: ['lower', 'upper']\n    });\n\n    if (!validOptions) {\n      return;\n    }\n\n    root.walkDecls(decl => {\n      const parsedValue = valueParser(getValue(decl));\n      let needsFix = false;\n      parsedValue.walk(node => {\n        const {\n          value\n        } = node;\n        if (isIgnoredFunction(node)) return false;\n        if (!isHexColor(node)) return;\n        const expected = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();\n        if (value === expected) return;\n\n        if (context.fix) {\n          node.value = expected;\n          needsFix = true;\n          return;\n        }\n\n        report({\n          message: messages.expected(value, expected),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName\n        });\n      });\n\n      if (needsFix) {\n        setValue(decl, parsedValue.toString());\n      }\n    });\n  };\n}\n\nfunction isIgnoredFunction({\n  type,\n  value\n}) {\n  return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());\n}\n\nfunction isHexColor({\n  type,\n  value\n}) {\n  return type === 'word' && HEX.test(value);\n}\n\nfunction getValue(decl) {\n  return decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n  if (decl.raws.value) decl.raws.value.raw = value;else decl.value = value;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;","map":{"version":3,"sources":["/Users/eduardol/workspace/app-test-laliga/node_modules/stylelint/lib/rules/color-hex-case/index.js"],"names":["valueParser","require","declarationValueIndex","report","ruleMessages","validateOptions","ruleName","messages","expected","actual","HEX","IGNORED_FUNCTIONS","Set","rule","expectation","options","context","root","result","validOptions","possible","walkDecls","decl","parsedValue","getValue","needsFix","walk","node","value","isIgnoredFunction","isHexColor","toLowerCase","toUpperCase","fix","message","index","sourceIndex","setValue","toString","type","has","test","raws","raw","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst declarationValueIndex = require('../../utils/declarationValueIndex');\nconst report = require('../../utils/report');\nconst ruleMessages = require('../../utils/ruleMessages');\nconst validateOptions = require('../../utils/validateOptions');\n\nconst ruleName = 'color-hex-case';\n\nconst messages = ruleMessages(ruleName, {\n\texpected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n});\n\nconst HEX = /^#[0-9A-Za-z]+/;\nconst IGNORED_FUNCTIONS = new Set(['url']);\n\nfunction rule(expectation, options, context) {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: expectation,\n\t\t\tpossible: ['lower', 'upper'],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkDecls((decl) => {\n\t\t\tconst parsedValue = valueParser(getValue(decl));\n\t\t\tlet needsFix = false;\n\n\t\t\tparsedValue.walk((node) => {\n\t\t\t\tconst { value } = node;\n\n\t\t\t\tif (isIgnoredFunction(node)) return false;\n\n\t\t\t\tif (!isHexColor(node)) return;\n\n\t\t\t\tconst expected = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();\n\n\t\t\t\tif (value === expected) return;\n\n\t\t\t\tif (context.fix) {\n\t\t\t\t\tnode.value = expected;\n\t\t\t\t\tneedsFix = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treport({\n\t\t\t\t\tmessage: messages.expected(value, expected),\n\t\t\t\t\tnode: decl,\n\t\t\t\t\tindex: declarationValueIndex(decl) + node.sourceIndex,\n\t\t\t\t\tresult,\n\t\t\t\t\truleName,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (needsFix) {\n\t\t\t\tsetValue(decl, parsedValue.toString());\n\t\t\t}\n\t\t});\n\t};\n}\n\nfunction isIgnoredFunction({ type, value }) {\n\treturn type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());\n}\n\nfunction isHexColor({ type, value }) {\n\treturn type === 'word' && HEX.test(value);\n}\n\nfunction getValue(decl) {\n\treturn decl.raws.value ? decl.raws.value.raw : decl.value;\n}\n\nfunction setValue(decl, value) {\n\tif (decl.raws.value) decl.raws.value.raw = value;\n\telse decl.value = value;\n}\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nmodule.exports = rule;\n"]},"metadata":{},"sourceType":"script"}